package parser

var tmpl =
`// Code generated by safe_channel
// DO NOT EDIT!
//
// safe_channel -type={{.ChannelType}} {{if .Name -}} -name={{.Name}}{{end}} {{if .ImportType -}} -import={{.ImportType}} {{end}}
//
package {{.PackageName}}

import ( 
    "context"
    "time"
{{if .ImportType -}} 
    "{{.ImportType}}" {{end}}
)

type {{.Name}}Channel struct {
	ctx     context.Context
	channel chan {{.ChannelType}}
}

func Create{{.Name}}Channel(ctx context.Context) {{.Name}}Channel {
	return {{.Name}}Channel{
		ctx:     ctx,
		channel: make(chan {{.ChannelType}}),
	}
}

func CreateBuffered{{.Name}}Channel(ctx context.Context, size int) {{.Name}}Channel {
	return {{.Name}}Channel{
		ctx:     ctx,
		channel: make(chan {{.ChannelType}}, size),
	}
}

func (c {{.Name}}Channel) Transmit(message {{.ChannelType}}) bool {
	select {
	case <-c.ctx.Done():
		return false
	case c.channel <- message:
		return true
	}
}

type TimeoutError struct {}
func (err TimeoutError) Error() string {
	return "timeout"
}

func (c {{.Name}}Channel) TransmitWithTimeout(message {{.ChannelType}}, timeout time.Duration) error {
	select {
	case <-c.ctx.Done():
		return c.ctx.Err()
	case <-time.After(timeout):
		return TimeoutError{}
	case c.channel <- message:
		return nil
	}
}

// C Небезопасный доступ к каналу.
// Чтение и запись в него всегда должны сопровождаться проверкой через select с.Context.Done().
// Нужен для того, чтобы в добавить в 'select' ещё каналы.
func (c {{.Name}}Channel) C() chan {{.ChannelType}} {
	return c.channel
}

func (c {{.Name}}Channel) Context() context.Context {
	return c.ctx
}

func (c {{.Name}}Channel) WaitReceive() (v {{.ChannelType}}, ok bool) {
	select {
	case <-c.ctx.Done():
		return v, false
	case v = <-c.channel:
		return v, true
	}
}

// связывает 2 канала, всё что приходит из канала from перенаправляется в канал to
// позволяет объеденять потоки из нескольких каналов в один
func (to {{.Name}}Channel) Tie(from {{.Name}}Channel, opts ...TieOption) {
	var tieOptions tieOptions
	for _, opt := range opts {
		opt(&tieOptions)
	}
	go retransmit(from, to, tieOptions.filter)
}

type tieOptions struct {
	filter func({{.ChannelType}}) ({{.ChannelType}}, bool)
}

type TieOption func(*tieOptions)

// можно отфильровать входящие сообщения, вернуть false, если сообщение надо отбросить
func Filter(filter func({{.ChannelType}}) ({{.ChannelType}}, bool)) TieOption {
	return func(opts *tieOptions) {
		opts.filter = filter
	}
}

// связывает 2 канала, всё что приходит из канала from перенаправляется в канал to
// если из канала to не прочитано сообщение из канала from, и приходит новое сообщение в канал from
// - вызывается функция оновления сообщения в канале, по-умолчанию старое заменяется
// позволяет объеденять потоки из нескольких каналов в один
// , при этом в канале лежит не более одного сообщения в один момент времени
func (to {{.Name}}Channel) TieWithUpdater(ctx context.Context, opts ... UpdateOption) {{.Name}}ChannelUpdater {
	from := CreateBuffered{{.Name}}Channel(ctx, 1)
	updateOptions := updateOptions{
		updateFunc: func(was, come {{.ChannelType}}) (become {{.ChannelType}}) {
			return come // по-умолчанию просто замена
		},
	}
	for _, opt := range opts {
		opt(&updateOptions)
	}
	go retransmitWithUpdate(from, to, updateOptions.updateFunc)
	return {{.Name}}ChannelUpdater(from)
}

type updateOptions struct {
	updateFunc func(was, come {{.ChannelType}}) (become {{.ChannelType}})
}

type UpdateOption func(*updateOptions)

// позволяет при приходе нового сообщения обновить сообщение в канале по необходимой логике
// по-умолчанию устанавливается функция, которая заменяет сообщение в канале на вновь прибывшее
func UpdateFunc(updateFunc func(was, come {{.ChannelType}}) (become {{.ChannelType}})) UpdateOption {
	return func(opts *updateOptions) {
		opts.updateFunc = updateFunc
	}
}

type {{.Name}}ChannelUpdater {{.Name}}Channel

func (ch {{.Name}}ChannelUpdater) Update(message {{.ChannelType}}) {
	{{.Name}}Channel(ch).Transmit(message)
}

func retransmit(from, to {{.Name}}Channel, filter func({{.ChannelType}}) ({{.ChannelType}}, bool)) {
	for {
		message, ok := from.WaitReceive()
		if !ok {
			return
		}
		if filter != nil {
			message, ok = filter(message)
		}
		if ok {
			ok = to.Transmit(message)
			if !ok {
				return
			}
		}
	}
}

func retransmitWithUpdate(from, to {{.Name}}Channel, updateFunc func(was, come {{.ChannelType}}) (become {{.ChannelType}})) {
	for {
		select {
		case message := <-from.C():
			send(from, to, message, updateFunc)
		case <-from.Context().Done():
			return
		}
	}
}

func send(from, to {{.Name}}Channel, message {{.ChannelType}}, updateFunc func(was, come {{.ChannelType}}) (become {{.ChannelType}})) {
	for {
		select {
		case newMessage := <-from.C():
			message = updateFunc(message, newMessage)
		case to.C() <- message:
			return
		case <-to.Context().Done():
			return
		}
	}
}
`


